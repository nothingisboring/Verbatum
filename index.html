<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordPath</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for better game feel */
        .cell {
            transition: all 0.2s ease-in-out;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }
        .cell.selected {
            background-color: #f59e0b; /* amber-500 */
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
        }
        /* Style for the anchor letter */
        .cell.anchor {
            background-color: #ca8a04; /* yellow-600 */
            box-shadow: 0 0 20px rgba(202, 138, 4, 0.7);
            transform: scale(1.1);
        }
        .cell.player-1 { background-color: #3b82f6; } /* blue-500 */
        .cell.player-2 { background-color: #ef4444; } /* red-500 */

        .cell-letter {
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }
        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        .modal-content {
            background-color: #27272a; /* zinc-800 */
            padding: 2rem;
            border-radius: 0.75rem;
            text-align: center;
            color: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="bg-zinc-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div id="game-container" class="w-full max-w-2xl mx-auto">
        <header class="text-center mb-4">
            <h1 class="text-4xl font-bold tracking-tighter">WordPath</h1>
            <p class="text-zinc-400">Anchor to your letter, build a path, and claim the board.</p>
        </header>

        <!-- Player Info & Turn Indicator -->
        <div id="info-panel" class="mb-4 p-4 bg-zinc-800 rounded-lg flex justify-between items-center">
            <div>
                <h2 class="text-lg font-semibold">Current Turn: <span id="turn-indicator" class="font-bold"></span></h2>
                <p class="text-sm text-zinc-400">Starter Word: <span id="starter-word-display" class="font-mono tracking-widest"></span></p>
            </div>
            <div id="player-colors" class="flex gap-4">
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-blue-500"></div>
                    <span>Player 1</span>
                </div>
                <div class="flex items-center gap-2">
                    <div class="w-4 h-4 rounded-full bg-red-500"></div>
                    <span>Player 2</span>
                </div>
            </div>
        </div>

        <!-- Game Board -->
        <div id="board" class="grid grid-cols-8 gap-1.5 aspect-[8/10] bg-zinc-900 p-2 rounded-lg shadow-inner">
            <!-- Cells will be generated by JavaScript -->
        </div>
        
        <!-- Controls -->
        <div id="controls" class="mt-4 flex flex-col sm:flex-row gap-3">
            <input type="text" id="word-input" placeholder="Click your letter to start..." class="flex-grow bg-zinc-800 border-2 border-zinc-700 rounded-lg px-4 py-2 focus:outline-none focus:border-amber-500 transition-colors text-white uppercase tracking-widest placeholder:text-zinc-500 disabled:opacity-50">
            <div class="flex gap-3">
                 <button id="submit-word" class="w-full sm:w-auto bg-green-600 hover:bg-green-500 transition-colors font-bold py-2 px-6 rounded-lg disabled:bg-zinc-600 disabled:cursor-not-allowed">Submit</button>
                 <button id="clear-selection" class="w-full sm:w-auto bg-zinc-600 hover:bg-zinc-500 transition-colors font-bold py-2 px-4 rounded-lg">Clear</button>
            </div>
        </div>

        <!-- Message Area -->
        <div id="message-area" class="text-center mt-4 h-6 text-amber-400 font-semibold"></div>
    </div>

    <!-- Winner Modal -->
    <div id="winner-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 id="winner-message" class="text-3xl font-bold mb-4"></h2>
            <p class="mb-6 text-zinc-300">A new path has been forged!</p>
            <button id="play-again" class="bg-amber-500 hover:bg-amber-400 text-zinc-900 font-bold py-3 px-8 rounded-lg">Play Again</button>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const BOARD_WIDTH = 8;
        const BOARD_HEIGHT = 10;
        const WORDNIK_API_KEY = "e3fhwhs2eb3firt9fp41rh44e1aibhqfmwzeb5vdcmn8xpph4";
        const STARTER_WORDS = {
            1: 'CREATORS',
            2: 'SPLATTER'
        };

        // --- DOM ELEMENTS ---
        const boardElement = document.getElementById('board');
        const turnIndicatorElement = document.getElementById('turn-indicator');
        const starterWordDisplayElement = document.getElementById('starter-word-display');
        const wordInputElement = document.getElementById('word-input');
        const submitButton = document.getElementById('submit-word');
        const clearButton = document.getElementById('clear-selection');
        const messageArea = document.getElementById('message-area');
        const winnerModal = document.getElementById('winner-modal');
        const winnerMessageElement = document.getElementById('winner-message');
        const playAgainButton = document.getElementById('play-again');
        
        // --- GAME STATE ---
        let boardState; 
        let currentPlayer;
        let selectedCells; // Array of {row, col}. First element is the anchor.
        let gameOver;

        // --- GAME LOGIC ---

        /**
         * Initializes the game state and renders the initial board.
         */
        function initGame() {
            boardState = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
            currentPlayer = 1;
            selectedCells = [];
            gameOver = false;

            placeWord(STARTER_WORDS[1], 0, 0, 1);
            placeWord(STARTER_WORDS[2], BOARD_HEIGHT - 1, 0, 2);
            
            winnerModal.classList.add('hidden');
            render();
        }

        /**
         * Places a word on the board state.
         */
        function placeWord(word, startRow, startCol, player) {
            for (let i = 0; i < word.length; i++) {
                if (startCol + i < BOARD_WIDTH) {
                    boardState[startRow][startCol + i] = { letter: word[i], player: player };
                }
            }
        }
        
        /**
         * Renders the entire game UI based on the current state.
         */
        function render() {
            renderBoard();
            updateInfoPanel();
            updateControls();
        }

        /**
         * Renders the game board cells.
         */
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                for (let col = 0; col < BOARD_WIDTH; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell', 'w-full', 'h-full', 'aspect-square', 'rounded-md', 'flex', 'items-center', 'justify-center', 'text-2xl', 'font-bold', 'uppercase', 'cursor-pointer');
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    const cellData = boardState[row][col];
                    if (cellData) {
                        cell.textContent = cellData.letter;
                        cell.classList.add(`player-${cellData.player}`);
                    } else {
                        cell.classList.add('bg-zinc-800', 'hover:bg-zinc-700');
                    }
                    
                    const selectionIndex = selectedCells.findIndex(c => c.row === row && c.col === col);
                    if (selectionIndex === 0) {
                        cell.classList.add('anchor');
                    } else if (selectionIndex > 0) {
                        cell.classList.add('selected');
                    }
                    
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    boardElement.appendChild(cell);
                }
            }
        }
        
        /**
         * Updates the turn indicator and other info.
         */
        function updateInfoPanel() {
            turnIndicatorElement.textContent = `Player ${currentPlayer}`;
            turnIndicatorElement.className = `font-bold ${currentPlayer === 1 ? 'text-blue-400' : 'text-red-400'}`;
            starterWordDisplayElement.textContent = STARTER_WORDS[currentPlayer];
        }

        /**
         * Enables/disables controls based on game state.
         */
        function updateControls() {
            const isSelectionMade = selectedCells.length > 0;
            wordInputElement.disabled = !isSelectionMade || gameOver;
            submitButton.disabled = !isSelectionMade || gameOver;
            if (gameOver) {
                wordInputElement.value = '';
                wordInputElement.placeholder = 'Game Over';
            } else if (isSelectionMade) {
                wordInputElement.placeholder = 'Type your word...';
            } else {
                 wordInputElement.placeholder = "Click your letter to start...";
            }
        }
        
        /**
         * Handles clicks on a board cell, allowing paths over opponent's letters.
         */
        function handleCellClick(row, col) {
            if (gameOver) return;

            const cellData = boardState[row][col];
            const cellIsSelected = selectedCells.some(c => c.row === row && c.col === col);

            if (selectedCells.length === 0) {
                if (cellData && cellData.player === currentPlayer) {
                    selectedCells.push({ row, col });
                    displayMessage('');
                } else {
                    displayMessage("Must start on one of your letters.", true);
                }
            } else {
                const lastCell = selectedCells[selectedCells.length - 1];
                const isAdjacent = Math.abs(lastCell.row - row) + Math.abs(lastCell.col - col) === 1;

                if (cellIsSelected) {
                    if (selectedCells.length === 1 && selectedCells[0].row === row && selectedCells[0].col === col) {
                         handleClearSelection();
                         return;
                    }
                } else if ((!cellData || cellData.player !== currentPlayer) && isAdjacent) {
                    // Path can go on empty cells OR opponent cells.
                    selectedCells.push({ row, col });
                } else {
                    displayMessage("Path must be adjacent and not on your own letters.", true);
                }
            }
            render();
        }

        /**
         * Clears the current selection and input.
         */
        function handleClearSelection() {
            selectedCells = [];
            wordInputElement.value = '';
            displayMessage('');
            render();
        }
        
        /**
         * Main function to handle word submission and validation with moving letters.
         */
        async function handleSubmitWord() {
            const word = wordInputElement.value.trim().toUpperCase();
            
            // --- 1. Basic Validation ---
            if (selectedCells.length === 0) {
                displayMessage("Select an anchor letter and path first.", true);
                return;
            }
            if (word.length !== selectedCells.length) {
                displayMessage("Word length must match selected path length.", true);
                return;
            }

            const anchorCell = selectedCells[0];
            const anchorLetter = boardState[anchorCell.row][anchorCell.col].letter;
            if (word[0] !== anchorLetter) {
                 displayMessage(`Word must start with anchor letter '${anchorLetter}'.`, true);
                 return;
            }

            if (!canPlayerFormWord(word, currentPlayer, selectedCells)) {
                displayMessage(`You don't have the letters on the board to spell that.`, true);
                return;
            }

            displayMessage("Checking word...", false);
            submitButton.disabled = true;

            // --- 2. API Validation ---
            const isValidWord = await checkWordWithAPI(word);
            if (!isValidWord) {
                displayMessage(`"${word}" is not a valid word.`, true);
                submitButton.disabled = false;
                return;
            }

            // --- 3. Consume Old Letters ---
            // Figure out which letters need to be moved from the player's stock.
            const lettersToMove = word.split('');
            for (let i = 0; i < selectedCells.length; i++) {
                const cell = selectedCells[i];
                const cellData = boardState[cell.row][cell.col];
                // If the cell is an opponent's tile, the letter for it is "created" by the steal,
                // so we don't need to find and move it from our stock.
                if (cellData && cellData.player !== currentPlayer) {
                    const letterProvidedBySteal = word[i];
                    const index = lettersToMove.indexOf(letterProvidedBySteal);
                    if (index > -1) {
                        lettersToMove.splice(index, 1);
                    }
                }
            }
            
            // Find and remove the tiles for the letters that are moving.
            for (let r = 0; r < BOARD_HEIGHT; r++) {
                for (let c = 0; c < BOARD_WIDTH; c++) {
                    if (lettersToMove.length === 0) break;
                    const cellData = boardState[r][c];
                    if (cellData && cellData.player === currentPlayer) {
                        const letterIndex = lettersToMove.indexOf(cellData.letter);
                        if (letterIndex > -1) {
                            lettersToMove.splice(letterIndex, 1);
                            boardState[r][c] = null; // Remove from old position
                        }
                    }
                }
                if (lettersToMove.length === 0) break;
            }

            // --- 4. Place New Word ---
            for (let i = 0; i < word.length; i++) {
                const { row, col } = selectedCells[i];
                boardState[row][col] = { letter: word[i], player: currentPlayer };
            }
            
            displayMessage(`"${word}" is valid!`, false);
            
            // --- 5. Check for Win & Switch Turn ---
            if (checkForWin()) {
                endGame();
            } else {
                switchPlayer();
                handleClearSelection();
            }
        }

        /**
         * [FIXED] Checks if the player can form the word from their own tiles + any stolen tiles.
         * @param {string} word The word to check.
         * @param {number} player The current player.
         * @param {object[]} selection The array of selected cells for the path.
         * @returns {boolean} True if the word can be formed.
         */
        function canPlayerFormWord(word, player, selection) {
            // 1. Get all letters the player currently owns on the board.
            const playerOwnedLetters = [];
            for (let r = 0; r < BOARD_HEIGHT; r++) {
                for (let c = 0; c < BOARD_WIDTH; c++) {
                    const cellData = boardState[r][c];
                    if (cellData && cellData.player === player) {
                        playerOwnedLetters.push(cellData.letter);
                    }
                }
            }

            // 2. Get the letters required for the word.
            const requiredLetters = word.split('');

            // 3. Account for letters "provided" by stealing.
            // Any letter placed on an opponent's tile doesn't need to come from the player's stock.
            for (let i = 0; i < selection.length; i++) {
                const cell = selection[i];
                const tileData = boardState[cell.row][cell.col];
                if (tileData && tileData.player !== player) {
                    // This position is a steal. The letter for this position in the new word
                    // doesn't need to be in the player's owned letters.
                    const letterToProvide = word[i];
                    const indexToRemove = requiredLetters.indexOf(letterToProvide);
                    if (indexToRemove > -1) {
                        requiredLetters.splice(indexToRemove, 1);
                    }
                }
            }

            // 4. Check if the remaining required letters can be satisfied by the player's stock.
            for (const letter of requiredLetters) {
                const index = playerOwnedLetters.indexOf(letter);
                if (index === -1) {
                    return false; // Player doesn't have this required letter.
                }
                playerOwnedLetters.splice(index, 1); // "Use" the letter from stock.
            }

            return true; // Player can form the word.
        }
        
        /**
         * Validates a word using the Wordnik API.
         */
        async function checkWordWithAPI(word) {
            if (!word) return false;
            const url = `https://api.wordnik.com/v4/word.json/${word.toLowerCase()}/definitions?limit=1&api_key=${WORDNIK_API_KEY}`;
            try {
                const response = await fetch(url);
                return response.ok;
            } catch (error) {
                console.error("Wordnik API error:", error);
                displayMessage("API error. Cannot validate word.", true);
                return false;
            }
        }
        
        /**
         * Switches the current player.
         */
        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
        }
        
        /**
         * Checks if the current player has won the game.
         */
        function checkForWin() {
            const targetRow = currentPlayer === 1 ? BOARD_HEIGHT - 1 : 0;
            for (let col = 0; col < BOARD_WIDTH; col++) {
                const cell = boardState[targetRow][col];
                if (cell && cell.player === currentPlayer) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Ends the game and displays the winner.
         */
        function endGame() {
            gameOver = true;
            winnerMessageElement.textContent = `Player ${currentPlayer} Wins!`;
            winnerModal.classList.remove('hidden');
            render();
        }
        
        /**
         * Displays a message to the user in the message area.
         */
        function displayMessage(text, isError = false) {
            messageArea.textContent = text;
            messageArea.className = `text-center mt-4 h-6 font-semibold ${isError ? 'text-red-500' : 'text-amber-400'}`;
            if(text) {
                setTimeout(() => {
                    if(messageArea.textContent === text) {
                       messageArea.textContent = '';
                    }
                }, 3000);
            }
        }
        
        // --- EVENT LISTENERS ---
        submitButton.addEventListener('click', handleSubmitWord);
        clearButton.addEventListener('click', handleClearSelection);
        playAgainButton.addEventListener('click', initGame);
        wordInputElement.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                handleSubmitWord();
            }
        });

        // --- INITIALIZE ---
        document.addEventListener('DOMContentLoaded', initGame);

    </script>
</body>
</html>
